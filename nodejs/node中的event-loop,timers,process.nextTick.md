# The Node.js Event Loop, Timers, and process.nextTick()

### 什么是事件轮循

事件轮循允许nodejs去执行非阻塞的I/O操作，尽管javascript运行在单线程之上，但在合适时机会尽可能将操作转移给系统内核去执行。

因为大多数现代浏览器内核都是多线程的，它们可以在后台同时处理多个操作，当其中某一操作完成时，内核就会通知nodejs，以让相应的回调callback添加到轮询队列里并最终执行。

### 事件轮询解析

当nodejs启动之后，会初始化事件轮询，处理已提供的输入脚本，这些脚本或许会发起异步API调用，调度定时器，或者调用process.nextTick方法，然后开始处理事件轮询。

下面这幅图展示了一个简化的事件轮询的操作顺序概览

![overview of event loop](https://img.souche.com/f2e/5f8cb81a03f88128acff2b938936835f.png)

注意：上述的每一块都指向事件轮询的某一个阶段

每一个阶段都有一个先进先出的队列去执行回调，然而每一个阶段都是特殊的，通常情况下，当事件轮询进入到一个特定的阶段时，将会执行特定于该阶段的任意操作，然后执行该阶段队列里的回调直到队列被耗尽或是执行了最大回调数。当队列被耗尽或达到了回调上线，事件轮询就将移动到下一个阶段，以此类推

由于任何操作都有可能去调度更多的操作，而且在轮询阶段处理的新事件由内核来进行排队，因为在处理轮询事件时，轮询事件是可以排队的。结果就是一个长时间执行的回调会允许轮询阶段去运行比定时器阀值更长的时间

注意：在windows和Umix/Linux的实现里有一些细微的差别，但对于这个演示并不重要，这里最重要的部分是确实有7到8个步骤，但我们最为关心的是nodejs实际上使用了上面哪些步骤

### 各个阶段概述

 - timers：这个阶段会执行setTimeout()或setInterval()所安排的回调函数
 - pending callbacks：执行延迟到下一个循环周期的I/O回调
 - idle，prepare：仅在内部使用
 - poll：检测新的I/O事件，执行I/O相关的回调（除了关闭的回调函数，以及定时器及setImmediate()所安排的事件），node会在此处阻塞
 - check：setImmediate回调会在这个阶段调用
 - close callbacks: 一些关闭回调会在该阶段进行调用，例如：socket.on('close', ...).

在每一次事件循环执行之间，nodejs都会去检查是否正在等待任何异步I/O或定时器，如果确定没有，则关闭干净

### 各个阶段详述